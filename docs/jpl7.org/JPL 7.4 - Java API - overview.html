<!DOCTYPE html>
<!-- saved from url=(0036)https://jpl7.org/JavaApiOverview.jsp -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
	
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="JPL 7.4.0 - a bidirectional programmatic interface between SWI Prolog 7.4 and Java SE Runtime Environment">
	<meta name="author" content="Paul Singleton">
	<link rel="icon" href="https://jpl7.org/img/favicon.ico">
	<link href="./JPL 7.4 - Java API - overview_files/bootstrap.min.css" rel="stylesheet">
	<link href="./JPL 7.4 - Java API - overview_files/jpl7.css" rel="stylesheet">



	<title>JPL 7.4 - Java API - overview</title>

	<style type="text/css">
		pre.code {
			display: table;
			padding-right: 5px;
		}
	</style>

	<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
	<!--[if lt IE 9]>
	<script src="lib/html5shiv.min.js"></script>
	<script src="lib/respond.min.js"></script>
	<![endif]-->
</head>
<body>
	<div class="container">
		<nav role="navigation" class="navbar navbar-default navbar-fixed-top">
			<!-- Brand and toggle get grouped for better mobile display -->
			<div class="navbar-header">
				<button type="button" data-target="#navbarCollapse" data-toggle="collapse" class="navbar-toggle">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a href="https://jpl7.org/ReleaseNotes701.jsp" class="navbar-brand" style="color:blue; font-size:200%; font-weight:bold;">JPL 7.4.0</a>
			</div>
			<div id="navbarCollapse" class="collapse navbar-collapse">
				<ul class="nav navbar-nav">
					<li class="dropdown">
						<a data-toggle="dropdown" class="dropdown-toggle" href="https://jpl7.org/JavaApiOverview.jsp#">Prolog API <b class="caret"></b></a>
						<ul role="menu" class="dropdown-menu">
							<li><a href="https://jpl7.org/PrologApiOverview.jsp" title="JPL - Prolog API - Overview">Overview</a></li>
							<li><a href="https://jpl7.org/PrologApiReference.jsp">Reference</a></li>
							<li><a href="http://www.swi-prolog.org/pldoc/doc/swi/library/jpl.pl">JPL docs at swi-prolog.org</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a data-toggle="dropdown" class="dropdown-toggle" href="https://jpl7.org/JavaApiOverview.jsp#">Java API <b class="caret"></b></a>
						<ul role="menu" class="dropdown-menu">
							<li><a href="https://jpl7.org/JavaApiOverview.jsp" title="JPL - Java API - Overview">Overview</a></li>
							<li><a href="https://jpl7.org/doc/index.html" target="_blank">JavaDoc</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a data-toggle="dropdown" class="dropdown-toggle" href="https://jpl7.org/JavaApiOverview.jsp#">Release notes <b class="caret"></b></a>
						<ul role="menu" class="dropdown-menu">
							<li><a href="https://jpl7.org/ReleaseNotes740.jsp">7.4.0</a></li>
							<li><a href="https://jpl7.org/ReleaseNotes701.jsp">7.0.1</a></li>
							<li><a href="https://jpl7.org/ReleaseNotes303.jsp">3.0.3</a></li>
							<li><a href="https://jpl7.org/ReleaseNotes302.jsp">3.0.2</a></li>
							<li><a href="https://jpl7.org/ReleaseNotes300.jsp">3.0.0</a></li>
							<li><a href="https://jpl7.org/ReleaseNotes202.jsp">2.0.2</a></li>
						</ul>
					</li>

				</ul>
			</div>
		</nav>



<h1>Java API - overview</h1>

<h3>Table of Contents</h3>

<ul>
  <li><a href="https://jpl7.org/JavaApiOverview.jsp#The%20Class%20Hierarchy">The Class Hierarchy</a></li>
  <li><a href="https://jpl7.org/JavaApiOverview.jsp#Initializing%20and%20Terminating%20Prolog">Initializing Prolog</a></li>
  <li><a href="https://jpl7.org/JavaApiOverview.jsp#Creating%20Terms">Creating Terms</a>
    <ul>
      <li><a href="https://jpl7.org/JavaApiOverview.jsp#Atoms">Atoms</a></li>
      <li><a href="https://jpl7.org/JavaApiOverview.jsp#Variables">Variables</a></li>
      <li><a href="https://jpl7.org/JavaApiOverview.jsp#Integers">Integers</a></li>
      <li><a href="https://jpl7.org/JavaApiOverview.jsp#Floats">Floats</a></li>
      <li><a href="https://jpl7.org/JavaApiOverview.jsp#Compound%20Terms">Compound Terms</a></li>
    </ul>
  </li>
  <li><a href="https://jpl7.org/JavaApiOverview.jsp#Creating%20Queries">Queries</a></li>

  <li><a href="https://jpl7.org/JavaApiOverview.jsp#Querying%20Prolog">Querying Prolog</a>
    <ul>
      <li><a href="https://jpl7.org/JavaApiOverview.jsp#Obtaining%20one%20Solution">Obtaining One Solution</a></li>
      <li><a href="https://jpl7.org/JavaApiOverview.jsp#Obtaining%20all%20Solutions">Obtaining all Solutions</a></li>
      <li><a href="https://jpl7.org/JavaApiOverview.jsp#Ground%20Queries">Discovering whether a Query has any Solutions</a></li>
      <li><a href="https://jpl7.org/JavaApiOverview.jsp#Terminating%20Queries">Terminating Queries</a></li>
    </ul>
  </li>
  <li><a href="https://jpl7.org/JavaApiOverview.jsp#Multi-Threaded%20Queries">Queries from multi-threaded applications</a></li>
  <li><a href="https://jpl7.org/JavaApiOverview.jsp#Exceptions">Exceptions</a></li>
  <li><a href="https://jpl7.org/JavaApiOverview.jsp#Debugging">Debugging</a></li>
  <li><a href="https://jpl7.org/JavaApiOverview.jsp#Version">Version information</a></li>
  <li><a href="https://jpl7.org/JavaApiOverview.jsp#Gotchas">Gotchas</a></li>
  <li><a href="https://jpl7.org/JavaApiOverview.jsp#What%27s%20Missing">What's Missing</a></li>
</ul>

<h3><a class="anchor" name="The Class Hierarchy"></a>The Class Hierarchy</h3>

<p>The <b><i>API</i></b> consists of the following class hierarchy:</p>

<pre class="code">org.jpl7
 +-- JPL
 +-- JPLException
 |    +-- PrologException
 +-- Query
 +-- Term
 |    +-- Atom
 |    +-- Compound
 |    +-- Float
 |    +-- Integer
 |    +-- Variable
 |    +-- JRef
 +-- Util
 +-- Version
</pre>

<p><code>org.jpl7.Term</code> is an abstract class: only its subclasses can be
	instantiated.</p>

<p>Each instance of <code>org.jpl7.Query</code> contains a <code>Term</code> (denoting the
	goal which is to be proven), and much more besides.</p>

<p>Each instance of <code>org.jpl7.Compound</code> has a java.lang.String name and
	an array of <code>Term</code> arguments.
	For compatibility with SWI-Prolog version 7's extension
	<a href="http://www.swi-prolog.org/pldoc/man?section=ext-compound-zero">Compound terms with zero arguments</a>,
	the argument array can be of zero length.
</p>

<h3><a class="anchor" name="Initializing and Terminating Prolog"></a>Initializing Prolog</h3>

<p>Typically, this is automatic.</p>

<p>JPL lazily initializes the Prolog VM, if necessary, when the first query
	is activated, using default initialization arguments (command line options). Before
	initialization takes place, these default values can be read, and altered.</p>

<pre class="code">public String[] getDefaultInitArgs();
public void setDefaultInitArgs(String[] args);
</pre>

<p>After initialization, the parameter values which were actually used
	can be read.</p>

<pre class="code">public String[] getActualInitArgs();
</pre>

<p>This method returns <code>null</code> if initialization has not
	occurred, and thus it can be used as a test. This allows Java
	library classes to employ JPL without placing any
	burden of initialization upon the applications which use them.
	It can also ensure that the Prolog VM is initialized only if and when it is needed.</p>

<p>Explicit initialization is supported:</p>

<pre class="code">public void init();
public void init(String args[]);
</pre>

<p>Java code which requires a Prolog VM to be initialized in a
	particular way can check whether initialization has already occurred:
	if not, it can specify parameters and force it to be attempted; if
	so, it can retrieve and check the initialisation parameters actually
	used, to determine whether the initialization meets its requirements.</p>

<p>JPL does not support reinitialization of a Prolog VM,
	but some command line options merely set flags,
	which can be altered later by calling <b>set_prolog_flag/2</b> via a JPL query.</p>

<p>For details about the legal parameter values, see
	<a href="http://www.swi-prolog.org/pldoc/man?section=cmdline">2.4 Command Line Options</a> in the
	<a href="http://www.swi-prolog.org/pldoc/doc_for?object=manual">SWI Prolog Reference Manual</a>.
	Most users will rely on automatic initialization.</p>

<h3><a class="anchor" name="Creating Terms"></a>Creating Terms</h3>

<p>The <code>Term</code>-based classes in the <code>org.jpl7</code> package are a structured concrete syntax for Prolog terms:
	they are not references to actual terms within the Prolog engine;
	rather, they are a means for constructing queries which can be called
	within Prolog, and they are also a means for representing (and
	exploring) the results
	of such calls.
	In particular, instances of <code>org.jpl7.Variable</code> are never bound nor shared; they are merely tokens.
</p>

<p><code>Term</code> instances are never changed by any
	activity within the Prolog engine: indeed; it doesn't know of their existence.</p>

<p>The <code>Term</code> class is abstract, so it cannot be directly instantiated; to create a Term,
	create an instance of one of its subclasses.</p>

<h4><a class="anchor" name="Atoms"></a>Atoms</h4>

<p>An <code>org.jpl7.Atom</code> instance represents a SWI Prolog text atom.
	To create an <code>Atom</code>, pass a (String) name to its constructor:</p>

<pre class="code">Atom a1 = new Atom("aristotle");
Atom a2 = new Atom("alexander");
</pre>

<p>As with Java strings, SWI Prolog text atoms represent arbitrarily long sequences of Unicode characters (including ASCII's nul).</p>

<p>Two <code>Atom</code> instances with the same name
	are effectively identical. Feel free to reuse atoms
	when constructing compound terms.</p>

<p>The name of an atom need not be lower case: it can be any
UCS string.</p>

<p>An atom's name is retrieved with its <code>name()</code> method, e.g.</p>

<pre class="code">a1.name()
</pre>

<p>See <code>Atom</code>'s <a href="http://192.168.1.49:8080/jpl7/doc/org/jpl7/Atom.html">JavaDoc</a> for details
	of how SWI Prolog version 7's strings and blobs (including reserved symbols) are accommodated.</p>

<h4><a class="anchor" name="Variables"></a>Variables</h4>

<p><code>org.jpl7.Variable</code> instances have identifying names, which must comply with conventional Prolog source text syntax.</p>

<pre class="code">Variable v1 = new Variable("X"); // a regular variable

Variable v2 = new Variable("_"); // an "anonymous" variable

Variable v3 = new Variable("_Y"); // a "dont-tell-me" variable, whose bindings we don't want to know
</pre>

<p>They are just tokens, and do not behave like Prolog variables.</p>

<h4><a class="anchor" name="Integers"></a>Integers</h4>

<p>A <code>org.jpl7.Integer</code> is a specialized <code>org.jpl7.Term</code> which holds a Java long
	value or a <code>java.math.BigInteger</code> object. This class corresponds to the Prolog <i>integer</i> type.</p>

<pre class="code">org.jpl7.Integer i = new org.jpl7.Integer(5);
</pre>

<p>Be careful to avoid confusion with <code>java.lang.Integer</code>, e.g.
	by qualifying the class name as in the example above.</p>

<p>The <code>org.jpl7.Integer</code> class has an <code>intValue()</code> accessor to obtain the <code>int</code> value of an instance,
	and also <code>longValue()</code>, <code>floatValue()</code> and <code>doubleValue()</code> (just like <code>java.lang.Integer</code> has).</p>

<p>If <code>isBig()</code> returns true, then the value is outside the range of a Java <code>long</code>, and is retrieved by <code>bigValue()</code>.</p>
<h4><a class="anchor" name="Floats"></a>Floats</h4>

<p>A <code>org.jpl7.Float</code> is a specialized <code>org.jpl7.Term</code> which holds a Java
<code>double</code> value. This class corresponds to the Prolog <i>float</i>
type (64-bit ISO/IEC in SWI Prolog).</p>

<pre class="code">org.jpl7.Float f = new org.jpl7.Float(3.14159265);
</pre>

<p>As with integers, take care to avoid confusion between <code>org.jpl7.Float</code> and <code>java.lang.Float</code>.</p>

<p>The <code>org.jpl7.Float</code> class has a <code>doubleValue()</code> accessor to obtain
	the <code>double</code> value of an instance, and also a <code>floatValue()</code> accessor.</p>

<h4><a class="anchor" name="Compound Terms"></a>Compounds</h4>

<p>A <code>org.jpl7.Compound</code> is a specialized <code>org.jpl7.Term</code> which contains a name and an
	array of <code>org.jpl7.Term</code> arguments, and can be constructed e.g.</p>

<pre class="code">Compound t1 = new Compound(
    "teacher_of",
    new Term[] {
        new Atom("aristotle"),
        new Atom("alexander")
    }
);
</pre>

<p>Note the use of Java's <i>anonymous array</i> syntax</p>

<pre class="code">new Term[] {..., ...}
</pre>

<p>to specify any quantity (perhaps zero) of arguments.</p>

<p>In this example, the Java variable <tt>t1</tt> refers to a
	<b>Compound</b> instance, which represents the Prolog term
	<i>teacher_of(aristotle, alexander)</i>.</p>



<p>To obtain the (String) name of a <b>Compound</b>, use the <b>name()</b>
	accessor method.</p>

<pre class="code">public String name();
</pre>

<p>To obtain the arity of a <b>Compound</b>, use the <b>arity()</b> accessor method.</p>

<pre class="code">public int arity();
</pre>

<p>To obtain an array of a <b>Compound</b>'s arguments, use the <b>args()</b> accessor method.</p>

<pre class="code">public Term[] args();
</pre>

<p>To obtain the <i>ith</i> argument of a compound (numbered from 1),
	use the <b>arg() </b>accessor method (with an <b>int </b>parameter
	value between 1 and Arity inclusive).</p>

<pre class="code">public Term arg(int i);
</pre>

<p>To obtain the <i>ith</i> argument of a compound (numbered from 0),
	use the <b>arg0() </b>accessor method (with an <b>int </b>parameter
	value between 0 and Arity-1 inclusive).</p>

<pre class="code">public Term arg0(int i);
</pre>

<h3><a class="anchor" name="Creating Queries"></a>Queries</h3>

<p>A <b>Query</b> contains a <b>Term</b>, representing a Prolog goal:</p>

<pre class="code">Term goal = new Compound("teacher_of", new Term[] {new Atom("aristotle"), new Atom("alexander")});
Query q = new Query(goal);
</pre>

<p>The <b>Query</b> <b>q</b> in this example represents the Prolog query</p>

<pre class="code">?- teacher_of(aristotle, alexander).
</pre>

<p><code>org.jpl7.Query</code> implements <code>java.util.Iterator</code>,
	allowing a query's solutions to be retrieved one at a time.</p>



<h3><a class="anchor" name="Querying Prolog"></a>Querying Prolog</h3>

<p>To ask the Prolog engine a query,
	one first constructs a <b>Query</b> instance, as in the above example,
	and then uses the <b>java.util.Iterator</b> interface, which the
	<b>Query</b> class implements, to obtain solutions (where a
	"solution" is what is known in logic programming jargon as
	a <i>substitution</i>, which is a collection of <i>bindings</i>, each
	of which relates one of the <b>Variables</b> within the <b>Query</b>'s
	goal to a <b>Term</b> representation of the Prolog term to which the
	corresponding Prolog variable was bound by the proof).</p>

<pre class="code">public interface Iterator {
    public boolean hasNext();
    public Object next();
}
</pre>

<p>The <code>hasNext()</code> method can be used to determine whether a query has any (or any further) solutions. In the above
	example, the method call</p>

<pre class="code">q.hasNext()
</pre>

<p>returns <code>true</code> if the Prolog query <i>teaches(aristotle, alexander)</i>
	is provable, and <code>false</code> otherwise. In this example, the
	Prolog query is a ground term, so the "solution" to the
	query is merely a truth value, and is given by the
	<code>hasNext()</code> method.</p>

<p>Where a query contains variables, on the
	other hand, its execution yields a sequence of bindings of the
	variables' names to <b>Term</b>s. JPL uses
	a <code>java.util.Map&lt;String, Term&gt;</code> (implemented as a <code>java.util.HashMap</code>) to represent these bindings; the objects
	in the map are <code>org.jpl7.Term</code> instances, keyed (uniquely) by the <code>String</code> names of their associated variables.</p>

<p>For example, to print all of Aristotle's pupils, i.e., all the
	bindings of <b>X</b> which satisfy <i>teaches(aristotle,X)</i>, one
	could write</p>

<pre class="code">Query q = new Query("teaches", new Term[] {new Atom("aristotle"), new Variable("X")});
while (q.hasNext()) {
    Map binding = q.next();
    Term t = (Term) binding.get("X");
    System.out.println(t);
}
</pre>

<p>or, more concisely</p>

<pre class="code">for (Map<string, term=""> m : new Query("teaches", new Term[] {new Atom("aristotle"), new Variable("X")})) {
    System.out.println(m.get("X"));
}
</string,></pre>

<p>or, using a convenience constructor which builds the term from Prolog source text</p>

<pre class="code">for (Map<string, term=""> m : new Query("teaches(aristotle,X)")) {
    System.out.println(m.get("X"));
}
</string,></pre>

<p>If a query's goal contains no variables (i.e. it is ground), the <code>Query.next()</code>method will return an emnpty map for
	each solution.</p>

<p>If a query's goal contains more than one occurrence of some (named) variable,
	then each solution will have
	only one binding for that name.</p>



<h4><a class="anchor" name="Obtaining one Solution"></a>Obtaining one Solution</h4>

<p>Often, you'll want just the first solution to a query;
	<code>org.jpl7.Query</code> has a method for this:</p>

<pre class="code">public final Map&lt;String, Term&gt; oneSolution();
</pre>

<p>If the query has no solutions, this method returns <code>null</code>;
	otherwise, a non-null return indicates success. If the query
	is ground (i.e. contains no variables), the returned
	map will be empty (i.e. will contain no bindings).</p>

<h4><a class="anchor" name="Obtaining all Solutions"></a>Obtaining all Solutions</h4>

<p>You may want all solutions to a query;
	<code>org.jpl7.Query</code> has a method for this:</p>

<pre class="code">public final Map&lt;String, Term&gt;[] allSolutions();
</pre>

<p>The returned array will contain all the query's solutions, in
	the order they were obtained (as with Prolog's findall/3, duplicates
	are not removed). If the query has no solutions, this
	method returns an empty array.</p>

<h4><a class="anchor" name="Ground Queries"></a>Discovering whether a query has any solutions</h4>

<p>Sometimes an application is interested only in whether a
	query is provable, but not in any details of its possible solutions;
	<code>org.jpl7.Query</code> has a method for
	this common special case:</p>

<pre class="code">public final boolean hasSolution();
</pre>

<p>This method is equivalent to
	calling <b>oneSolution</b> and asking whether the return value is
	non-<b>null</b> (i.e. whether the query succeeded).</p>

<h4><a class="anchor" name="Terminating Queries"></a>Terminating Queries</h4>

<p>Queries terminate automatically when <code>hasNext()</code>
	returns <code>false</code> (or when <code>next()</code> throws an exception), and once a query has
	terminated, its engine is returned to the pool for reuse (by any thread).</p>

<p>To terminate a query before all of its solutions have been
	exhausted, use its <code>close()</code> method:</p>

<pre class="code">public final void close();
</pre>

<p>This method stops a query, setting it back into a state where
	it can be restarted. Here is an example in which the first three solutions
	to the query are obtained:</p>

<pre class="code">Query query = // obtain Query somehow
for (int i = 0; i &lt; 3 &amp;&amp; query.hasNext(); ++i) {
    Map&lt;String, Term&gt; solution = query.next();
    // process solution...
}
query.close();
</pre>

<p>You may call <code>close()</code> on an inactive query without
	ill-effect, and you should <i>always</i> call close if you have not
	exhausted all solutions to a query, otherwise the associated Prolog engine will not be released.</p>

<p>If you are using the <code>allSolutions()</code>, <code>hasSolution()</code>, <code>nSolutions()</code>, or
	<code>oneSolution()</code> methods, you need not worry about closing the
	query; it is done automatically for you.</p>

<p>See <a href="https://github.com/ssardina-research/packages-jpl/wiki/Types-of-Queries:-One-shot-vs-Iterative">Types of Queries: One shot vs Iterative</a> (in <a href="https://github.com/ssardina-research/packages-jpl/wiki">Sebastian Sardina's JPL Wiki</a>) for further details and explanation.</p>

<h3><a class="anchor" name="Multi-Threaded Queries"></a>Queries from multi-threaded applications</h3>

<p>JPL maintains a finite pool of Prolog engines, one of which is allocated to a query when it is activated (i.e. when, one way or another, a solution is requested).
	A query's engine is returned to the pool when it is closed (explicitly or automatically).</p>

<p>If no pool engine is available when a query is activated, the activation is blocked until an engine becomes available.</p>

<p>Each JVM thread can have at most one Prolog engine attached.  A thread may nest (stack) two or more active queries,
	e.g. open and close a second query while a first is active, but it may not interleave the retrieval of solutions from two open queries.</p>

<p>Note that engines cannot communicate thread_local predicates or global variables.
	That means that you can only use these from Java within a single query.
	If a thread activates two consecutive queries, it may get two different engines.</p>

<p>Note also that, once a thread has activated a query, it cannot pass it to another thread:
	solutions of a query must be retrieved by the thread which activated it.</p>

<p>See <a href="https://github.com/ssardina-research/packages-jpl/wiki/Multi-Threaded-Queries">Multi Threaded Queries</a> (in <a href="https://github.com/ssardina-research/packages-jpl/wiki">Sebastian Sardina's JPL Wiki</a>) for further details and explanation.</p>

<h3><a class="anchor" name="Exceptions"></a>Exceptions</h3>

<p>JPL provides crude but adequate exception handling.
	The base class for all exceptions is <code>org.jpl7.JPLException</code>,
	which specialises <code>java.lang.RuntimeException</code> and hence is unchecked.
	Converting the exception to a <b>java.lang.String</b> should provide some descriptive
	information about the reason for the error.
	JPL's only other exception class is <code>org.jpl7.PrologException</code>,
	which extends <code>org.jpl7.JPLException</code>.</p>

<p>A <code>org.jpl7.PrologException</code> is thrown either during execution of a
  Prolog built-in predicate or by an explicit call of <code>throw/1</code> by application code.</p>


<h3><a class="anchor" name="Debugging"></a>Debugging</h3>

<p>Each <b>Term</b> type (together with the <b>Query</b> class)
  supports an implementation of <b>toString()</b> which returns a
  more-or-less familiar Prolog textual representation of the <b>Term</b>
  or <b>Query</b>.</p>

<p>In general, <b>Term</b> and <b>Query</b> instances are represented
  in the form (<i>type data</i>), where <i>type</i> is the name of the
  type (e.g., <b>Atom</b>, <b>Compound</b>, <b>Tuple</b>, etc.), and
  <i>data</i> is a representation of the contents of the <b>Term</b>.
  For example, if the <b>Term</b> is an <b>Atom</b>, the data is the
  <b>Atom</b>'s name. The arguments of <b>Compounds</b> are
  represented by comma-separated lists within square brackets ('[' ']').</p>

<p>Viewing the structure of a term or query can be
  useful in determining whether an error lies on the Prolog or Java
  side of your JPL applications.</p>

<h3><a class="anchor" name="Version"></a>Version information</h3>

<p>To obtain the current version of JPL you are using,
  you may obtain a static reference to the <code>org.jpl7.Version</code> class by calling the <code>org.jpl7.JPL#version</code> static
  method. This will return a <code>org.jpl7.Version</code> structure, which
  has the following final fields:</p>

<pre class="code">package org.jpl7;
public class Version {
    public final int major;                // e.g. 7
    public final int minor;                // e.g. 4
    public final int patch;                // e.g. 0
    public final java.lang.String status;  // e.g. "alpha"
}
</pre>

<p>You may wish to use this class instance to obtain fine-grained
  information about the current JPL version, e.g.
</p>
<pre class="code">if (JPL.version().major == 7) {
</pre>
<p>You may also call the <code>version_string()</code> static method of
  the <code>org.jpl7.JPL</code> class. This will return a String
  representation of the current JPL version.
</p>
<p>The version string can be written to the standard output stream by
  running the <b>main()</b> method of the <code>org.jpl7.JPL</code> class.
</p>
<pre class="code">linux% java org.jpl7.JPL
JPL 7.4.0-alpha
</pre>

<h3>
  <a class="anchor" name="Gotchas"></a>
  Gotchas
</h3>

<h4>arg indexing</h4>
<p>The <code>Term[]</code> args of
  a <code>Compound</code> are indexed (like
  all Java arrays) from zero, whereas in Prolog the args of a structure
  are conventionally numbered from one.
</p>

<h4>representing <code>@(null)</code></h4>
<p>there is no <code>org.jpl7.JNull</code>
  class: instead, use <code>new JRef(null)</code> to represent <code>@(null)</code>
  (which itself represents Java's <code>null</code>).
  If you don't know what this all means, don't worry: it only affects
  those writing hybrid Java+Prolog programs which call each other
  nestedly.
</p>

<h4>all solutions of a Query with no solutions</h4>
<p><code>Query.allSolutions()</code>
  returns an empty array of <code>Map&lt;String, Term&gt;</code>
  if the query has no solutions
  (in 1.x versions it inconsistently returned null).
</p>

<hr size="4" noshade="noshade">
<p align="right" style="margin-bottom: 0cm;"><a href="https://jpl7.org/index.html">up</a>
<a href="https://jpl7.org/low-level_interface.html">prev</a> next <a href="https://jpl7.org/api/packages.html">API</a></p>

	</div>
	<script src="./JPL 7.4 - Java API - overview_files/jquery.min.js"></script>
	<script src="./JPL 7.4 - Java API - overview_files/bootstrap.min.js"></script>
	<script src="./JPL 7.4 - Java API - overview_files/ie10-viewport-bug-workaround.js"></script> <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->





</body></html>